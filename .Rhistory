transulnet = function(d0, dA, method = c("suni_tsloo","suni_sloo","suni_s"), negOnly = FALSE,
...){
################################################################################
## target data setup
method <- match.arg(method)
this.call <- match.call()
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y) != nobs0)
stop("x and y have different number of observations")
if (NCOL(y) > 1L) stop("Multivariate response is not supported now")
################################################################################
## source data setup
pA <- unique(sapply(dA, function(x){dim(x$x)[2]}))
if(length(pA)!=1 | pA[1]!=nvars){
stop("Source data has different number of variables from target data")
}else{
yA <- unlist(lapply(dA, function(item) item$y))
xA <- do.call(rbind, lapply(dA, function(item) item$x))
}
################################################################################
## Step 1, univariate fits
nobsA <- nrow(xA)
nobs <- as.integer(nobs0 + nobsA)
new_y <- switch(method,
suni_tsloo = as.double(c(y0,yA)),
suni_sloo = as.double(y0),
suni_s = as.double(y0))
unifit <- switch(method,
suni_tsloo = .Fortran("loofit_ts", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs * nvars),
PACKAGE = "sulnet"),
suni_sloo  = .Fortran("loofit_s", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet"),
suni_s  = .Fortran("loofit_st", nobs0, nvars, nobsA, as.double(x0), as.double(y0),
as.double(xA),
as.double(yA),
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet")
)
unibeta = unifit$beta
unibeta0 = unifit$beta0
f <- matrix(unifit$fit, ncol = nvars)
colnames(f) = vnames
################################################################################
## parameter setup
args <- list(...)
args$negOnly <- TRUE
args$x <- f
args$y <- new_y
################################################################################
## Step 2, lasso using univariate fits
lsfit = do.call(sulnet2D, args)
lsfit
}
transulnet = function(d0, dA, method = c("suni_tsloo","suni_sloo","suni_s"),
...){
################################################################################
## target data setup
method <- match.arg(method)
this.call <- match.call()
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y) != nobs0)
stop("x and y have different number of observations")
if (NCOL(y) > 1L) stop("Multivariate response is not supported now")
################################################################################
## source data setup
pA <- unique(sapply(dA, function(x){dim(x$x)[2]}))
if(length(pA)!=1 | pA[1]!=nvars){
stop("Source data has different number of variables from target data")
}else{
yA <- unlist(lapply(dA, function(item) item$y))
xA <- do.call(rbind, lapply(dA, function(item) item$x))
}
################################################################################
## Step 1, univariate fits
nobsA <- nrow(xA)
nobs <- as.integer(nobs0 + nobsA)
new_y <- switch(method,
suni_tsloo = as.double(c(y0,yA)),
suni_sloo = as.double(y0),
suni_s = as.double(y0))
unifit <- switch(method,
suni_tsloo = .Fortran("loofit_ts", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs * nvars),
PACKAGE = "sulnet"),
suni_sloo  = .Fortran("loofit_s", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet"),
suni_s  = .Fortran("loofit_st", nobs0, nvars, nobsA, as.double(x0), as.double(y0),
as.double(xA),
as.double(yA),
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet")
)
unibeta = unifit$beta
unibeta0 = unifit$beta0
f <- matrix(unifit$fit, ncol = nvars)
colnames(f) = vnames
################################################################################
## parameter setup
args <- list(...)
args$negOnly <- TRUE
args$x <- f
args$y <- new_y
################################################################################
## Step 2, lasso using univariate fits
lsfit = do.call(sulnet2D, args)
lsfit
}
a = transulnet(d0,dA)
d0
method = "suni_tsloo"
################################################################################
## target data setup
method <- match.arg(method)
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y) != nobs0)
stop("x and y have different number of observations")
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y0) != nobs0)
stop("x and y have different number of observations")
if (NCOL(y0) > 1L) stop("Multivariate response is not supported now")
################################################################################
## source data setup
pA <- unique(sapply(dA, function(x){dim(x$x)[2]}))
if(length(pA)!=1 | pA[1]!=nvars){
stop("Source data has different number of variables from target data")
}else{
yA <- unlist(lapply(dA, function(item) item$y))
xA <- do.call(rbind, lapply(dA, function(item) item$x))
}
################################################################################
## Step 1, univariate fits
nobsA <- nrow(xA)
nobs <- as.integer(nobs0 + nobsA)
new_y <- switch(method,
suni_tsloo = as.double(c(y0,yA)),
suni_sloo = as.double(y0),
suni_s = as.double(y0))
unifit <- switch(method,
suni_tsloo = .Fortran("loofit_ts", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs * nvars),
PACKAGE = "sulnet"),
suni_sloo  = .Fortran("loofit_s", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet"),
suni_s  = .Fortran("loofit_st", nobs0, nvars, nobsA, as.double(x0), as.double(y0),
as.double(xA),
as.double(yA),
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet")
)
unibeta = unifit$beta
unibeta0 = unifit$beta0
f <- matrix(unifit$fit, ncol = nvars)
colnames(f) = vnames
################################################################################
## parameter setup
args <- list(...)
args$negOnly <- TRUE
transulnet = function(d0, dA, method = c("suni_tsloo","suni_sloo","suni_s"),
...){
################################################################################
## target data setup
method <- match.arg(method)
this.call <- match.call()
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y0) != nobs0)
stop("x and y have different number of observations")
if (NCOL(y0) > 1L) stop("Multivariate response is not supported now")
################################################################################
## source data setup
pA <- unique(sapply(dA, function(x){dim(x$x)[2]}))
if(length(pA)!=1 | pA[1]!=nvars){
stop("Source data has different number of variables from target data")
}else{
yA <- unlist(lapply(dA, function(item) item$y))
xA <- do.call(rbind, lapply(dA, function(item) item$x))
}
################################################################################
## Step 1, univariate fits
nobsA <- nrow(xA)
nobs <- as.integer(nobs0 + nobsA)
new_y <- switch(method,
suni_tsloo = as.double(c(y0,yA)),
suni_sloo = as.double(y0),
suni_s = as.double(y0))
unifit <- switch(method,
suni_tsloo = .Fortran("loofit_ts", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs * nvars),
PACKAGE = "sulnet"),
suni_sloo  = .Fortran("loofit_s", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet"),
suni_s  = .Fortran("loofit_st", nobs0, nvars, nobsA, as.double(x0), as.double(y0),
as.double(xA),
as.double(yA),
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet")
)
unibeta = unifit$beta
unibeta0 = unifit$beta0
f <- matrix(unifit$fit, ncol = nvars)
colnames(f) = vnames
################################################################################
## parameter setup
args <- list(...)
args$negOnly <- TRUE
args$x <- f
args$y <- new_y
################################################################################
## Step 2, lasso using univariate fits
lsfit = do.call(sulnet2D, args)
lsfit
}
temp = transulnet(d0,dA)
temp$negOnly
temp$use_alpha
?lapply
lsfit = temp
forseq = ifelse(lsfit$use_alpha, length(lsfit$alpha), length(lsfit$lamPos))
forseq
ones = rep(1,length(lsfit$lambda))
unibeta <- outer(unibeta, ones)
unibeta0 <- outer(unibeta0, ones)
new_lsfit = lapply(seq_along(forseq), function(x){
multuni(lsfit$beta[[x]], lsfit$b0[[x]],
unibeta, unibeta0)
})
multuni <- function(beta_temp, beta0_temp, unibeta, unibeta0){
row_idx <- beta_temp@i + 1
col_ptrs <- beta_temp@p
col_idx <- rep(seq_along(col_ptrs[-1]), diff(col_ptrs))
beta_result <- beta_temp
beta_result@x <- beta_temp@x * unibeta[cbind(row_idx, col_idx)]
list(beta = beta_result,
b0 = beta0_temp + colSums(unibeta0 * beta_temp)
)
}
new_lsfit = lapply(seq_along(forseq), function(x){
multuni(lsfit$beta[[x]], lsfit$b0[[x]],
unibeta, unibeta0)
})
new_lsfit$beta
seq_along(forseq)
new_lsfit = lapply(seq(forseq), function(x){
multuni(lsfit$beta[[x]], lsfit$b0[[x]],
unibeta, unibeta0)
})
transulnet = function(d0, dA, method = c("suni_tsloo","suni_sloo","suni_s"),
...){
################################################################################
## target data setup
method <- match.arg(method)
this.call <- match.call()
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y0) != nobs0)
stop("x and y have different number of observations")
if (NCOL(y0) > 1L) stop("Multivariate response is not supported now")
################################################################################
## source data setup
pA <- unique(sapply(dA, function(x){dim(x$x)[2]}))
if(length(pA)!=1 | pA[1]!=nvars){
stop("Source data has different number of variables from target data")
}else{
yA <- unlist(lapply(dA, function(item) item$y))
xA <- do.call(rbind, lapply(dA, function(item) item$x))
}
################################################################################
## Step 1, univariate fits
nobsA <- nrow(xA)
nobs <- as.integer(nobs0 + nobsA)
new_y <- switch(method,
suni_tsloo = as.double(c(y0,yA)),
suni_sloo = as.double(y0),
suni_s = as.double(y0))
unifit <- switch(method,
suni_tsloo = .Fortran("loofit_ts", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs * nvars),
PACKAGE = "sulnet"),
suni_sloo  = .Fortran("loofit_s", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet"),
suni_s  = .Fortran("loofit_st", nobs0, nvars, nobsA, as.double(x0), as.double(y0),
as.double(xA),
as.double(yA),
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet")
)
unibeta = unifit$beta
unibeta0 = unifit$beta0
f <- matrix(unifit$fit, ncol = nvars)
colnames(f) = vnames
################################################################################
## parameter setup
args <- list(...)
args$negOnly <- TRUE
args$x <- f
args$y <- new_y
################################################################################
## Step 2, lasso using univariate fits
lsfit = do.call(sulnet2D, args)
################################################################################
## Step 3, lasso using univariate fits
forseq = ifelse(lsfit$use_alpha, length(lsfit$alpha), length(lsfit$lamPos))
ones = rep(1,length(lsfit$lambda))
unibeta <- outer(unibeta, ones)
unibeta0 <- outer(unibeta0, ones)
new_lsfit = lapply(seq(forseq), function(x){
multuni(lsfit$beta[[x]], lsfit$b0[[x]],
unibeta, unibeta0)
})
beta_list <- lapply(new_lsfit, function(x) x$beta)
b0_list   <- lapply(new_lsfit, function(x) x$b0)
outlist = lsfit
outlist$beta = beta_list
outlist$b0 = b0_list
outlist$fbeta = lsfit$beta
outlist$fb0 = lsfit$b0
class(outlist) = "sulnet2D.sunipath_2"
outlist
}
temp = transulnet(d0,dA)
temp$beta
names(lsfit$beta)
transulnet = function(d0, dA, method = c("suni_tsloo","suni_sloo","suni_s"),
...){
################################################################################
## target data setup
method <- match.arg(method)
this.call <- match.call()
y0 <- drop(d0$y)
x0 <- as.matrix(d0$x)
np <- dim(x0)
nobs0 <- as.integer(np[1])
nvars <- as.integer(np[2])
vnames <- colnames(x0)
if (is.null(vnames))
vnames <- paste("V", seq(nvars), sep = "")
if (NROW(y0) != nobs0)
stop("x and y have different number of observations")
if (NCOL(y0) > 1L) stop("Multivariate response is not supported now")
################################################################################
## source data setup
pA <- unique(sapply(dA, function(x){dim(x$x)[2]}))
if(length(pA)!=1 | pA[1]!=nvars){
stop("Source data has different number of variables from target data")
}else{
yA <- unlist(lapply(dA, function(item) item$y))
xA <- do.call(rbind, lapply(dA, function(item) item$x))
}
################################################################################
## Step 1, univariate fits
nobsA <- nrow(xA)
nobs <- as.integer(nobs0 + nobsA)
new_y <- switch(method,
suni_tsloo = as.double(c(y0,yA)),
suni_sloo = as.double(y0),
suni_s = as.double(y0))
unifit <- switch(method,
suni_tsloo = .Fortran("loofit_ts", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs * nvars),
PACKAGE = "sulnet"),
suni_sloo  = .Fortran("loofit_s", nobs, nobs0, nvars, as.double(x0), as.double(y0),
as.double(rbind(x0,xA)),
as.double(c(y0,yA)), loo,
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet"),
suni_s  = .Fortran("loofit_st", nobs0, nvars, nobsA, as.double(x0), as.double(y0),
as.double(xA),
as.double(yA),
beta0 = double(nvars),
beta = double(nvars),
fit = double(nobs0 * nvars),
PACKAGE = "sulnet")
)
unibeta = unifit$beta
unibeta0 = unifit$beta0
f <- matrix(unifit$fit, ncol = nvars)
colnames(f) = vnames
################################################################################
## parameter setup
args <- list(...)
args$negOnly <- TRUE
args$x <- f
args$y <- new_y
################################################################################
## Step 2, lasso using univariate fits
lsfit = do.call(sulnet2D, args)
################################################################################
## Step 3, lasso using univariate fits
forseq = ifelse(lsfit$use_alpha, length(lsfit$alpha), length(lsfit$lamPos))
ones = rep(1,length(lsfit$lambda))
unibeta <- outer(unibeta, ones)
unibeta0 <- outer(unibeta0, ones)
new_lsfit = lapply(seq(forseq), function(x){
multuni(lsfit$beta[[x]], lsfit$b0[[x]],
unibeta, unibeta0)
})
beta_list <- lapply(new_lsfit, function(x) x$beta)
names(beta_list) = names(lsfit$beta)
b0_list <- lapply(new_lsfit, function(x) x$b0)
names(b0_list)  = names(lsfit$b0)
outlist = lsfit
outlist$beta = beta_list
outlist$b0 = b0_list
outlist$fbeta = lsfit$beta
outlist$fb0 = lsfit$b0
class(outlist) = "sulnet2D.sunipath_2"
outlist
}
temp = transulnet(d0,dA)
temp$beta$alpha_0
